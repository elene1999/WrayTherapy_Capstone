import { BaseActor } from "../../actor/BaseActor";
import { Camera } from "./Camera";
import { XY } from "./XY";
import { JetLagStage } from "../JetLagStage";
import { JetLagKeys } from "../../support/JetLagKeys";

/**
 * JetLagDevice bundles the abstractions of the parts of a game device.  This
 * lets the rest of JetLag use JetLagDevice, instead of needing to have
 * references to the various subsystems' abstractions.  The individual
 * components of the JetLagDevice abstract away the differences between
 * different device types (true HTML browser, Cordova), so that the rest of
 * JetLag can be completely device-agnostic.
 */
export interface JetLagDevice {
    /** Return the abstract TouchScreen */
    getTouchScreen(): JetLagTouchScreen;

    /** Return the abstract Keyboard */
    getKeyboard(): JetLagKeyboard;

    /** Return the abstract Accelerometer */
    getAccelerometer(): JetLagAccelerometer;

    /** Return the abstract Renderer */
    getRenderer(): JetLagRenderer;

    /** Return the abstract Vibration device */
    getVibration(): JetLagVibration;

    /** Return the abstract Audio device */
    getSpeaker(): JetLagSpeaker;

    /** Return the abstract Storage interface */
    getStorage(): JetLagStorage;

    /** Return the abstraction of processes for this device */
    getProcess(): JetLagProcess;

    /** Return the abstract debug console */
    getConsole(): JetLagConsole;
}

/**
 * TouchReceiver provides handlers to run in response to all of the gestures
 * that we care about.
 */
export interface JetLagTouchReceiver {
    /** Code to run in response to a tap event */
    tap(screenX: number, screenY: number): void;
    /** Code to run in response to the start of a pan event */
    panStart(screenX: number, screenY: number): void;
    /** Code to run when a pan move event happens */
    panMove(screenX: number, screenY: number): void;
    /** Code to run when a pan event ends */
    panStop(screenX: number, screenY: number): void;
    /** Code to run when a touch down happens */
    touchDown(screenX: number, screenY: number): void;
    /** Code to run when a touch up happens */
    touchUp(screenX: number, screenY: number): void;
    /** Code to run in response to a swipe */
    swipe(x0: number, y0: number, x1: number, y1: number, time: number): void;
}

/**
 * TouchScreen abstracts away how gestures (pan, swipe, tap, rotate, pinch,
 * press) are generated by the device, and sends them to a JetLagTouchReceiver
 * (which is probably the JetLagStage).
 *
 * Based on how JetLag is designed, we can get by with a single subscriber for
 * each gesture event
 */
export interface JetLagTouchScreen {
    setTouchReceiver(receiver: JetLagTouchReceiver): void;
}

/**
 * Keyboard provides a way of getting keystrokes and routing them to the current
 * stage
 */
export interface JetLagKeyboard {
    /**
     * Set the code to run when a key is pressed down
     * 
     * @param key The key to respond to
     * @param handler The code to run when the key is pressed down
     */
    setKeyDownHandler(key: JetLagKeys, handler: () => void): void;

    /**
     * Set the code to run when a key is released
     * @param key The key to respond to
     * @param handler The code to run when the key is released
     */
    setKeyUpHandler(key: JetLagKeys, handler: () => void): void;

    /** reset all key handlers (i.e., on level change) */
    clearHandlers(): void;
}

/**
 * Accelerometer provides a way of getting accelerometer input and routing it to
 * the current stage
 */
export interface JetLagAccelerometer {
    /** Get the X and Y forces of the accelerometer */
    get(): XY;
    /** Forcibly set the accelerometer X force */
    setX(x: number): void;
    /** Forcibly set the accelerometer Y force */
    setY(y: number): void;
    /** Report if the device has an accelerometer */
    getSupported(): boolean;
}

/** Renderer abstracts away differences between rendering engines */
export interface JetLagRenderer {
    /** Add an Actor to the next frame to be rendered */
    addActorToFrame(actor: BaseActor, camera: Camera): void;
    /** Set the background color for the next frame to be rendered */
    setFrameColor(color: number): void;
    /** Load all the assets that will be drawn in the future by the renderer */
    loadAssets(callback: () => void): void;
    /** Add a picture to the next frame to be rendered */
    addPictureToFrame(sprite: JetLagSprite, camera: Camera): void;
    /** Start rendering frames */
    startRenderLoop(stage: JetLagStage): void;
    /** Get the next frame ready to render */
    initFrame(): void;
    /** Show the frame that we've been preparing to render */
    showFrame(): void;
    /** Add some text to the next frame to render */
    addTextToFrame(text: JetLagText, camera: Camera, center: boolean): void;
    /** Create a renderable sprite */
    getSprite(imgName: string): JetLagSprite;
    /** Report the renderer's frames per second */
    getFPS(): number;
    /** Create a renderable text object */
    makeText(txt: string, opts: any): JetLagText;
    /** Create a debug context, for debug rendering */
    makeDebugContext(): JetLagDebugSprite;
}

/** Vibration provides an abstract interface for vibrating the device */
export interface JetLagVibration {
    /** Vibrate the device for a number of milliseconds */
    vibrate(millis: number): void;
}

/** Speaker is a representation of the device's audio context */
export interface JetLagSpeaker {
    /**
     * Return a sound that can be played
     * 
     * @param soundName The name of the sound to get
     */
    getSound(soundName: string): JetLagSound;

    /**
     * Return a music object that can be played
     * 
     * @param musicName The name of the music to get
     */
    getMusic(musicName: string): JetLagSound;

    /**
     * Reset the music volume for all sounds and music files
     * 
     * @param volume The new volume (scale from 0 to 1)
     */
    resetMusicVolume(volume: number): void;
}

/** An abstract representation of three key/value stores */
export interface JetLagStorage {
    /** Clear all the facts for a level */
    clearLevelFacts(): void;
    /** Set a fact that lasts only for the current level */
    setLevel(key: string, value: any): void;
    /** Get a fact that was set for the current level */
    getLevel(key: string, defaultVal: any): string;
    /** Set a fact that will remain until the game is quit */
    setSession(key: string, value: any): void;
    /** Get a fact that lasts until the game is quit */
    getSession(key: string, defaultVal: any): string;
    /** Set a fact that lasts even after the game is quit */
    setPersistent(key: string, value: string): void;
    /** Get a fact that lasts even after the game is quit */
    getPersistent(key: string, defaultVal: string): string;
}

/**
 * Process abstracts away what it means to be a process in the given execution
 * environment, so that we can handle quit requests in a device-agnostic way.
 */
export interface JetLagProcess {
    /**
     * Exit the current process, terminate the app, close the window, or
     * whatever else it might mean to exit.
     */
    exit(): void;
}

/** A representation of the device console */
export interface JetLagConsole {
    /** Display an urgent message */
    urgent(msg: string): void;
    /** Display an informative message */
    info(msg: string): void;
}

/**
 * We are probably going to need a way to re-interpret the meaning of
 * accelerometer values depending on the orientation of the device (at least
 * portrait vs. landscape).  Until we have a use case, we'll just anticipate as
 * best we can by having this enum to pass to the constructor.
 */
export enum JetLagAccelerometerMode {
    DEFAULT_LANDSCAPE,
}

/** An abstract representation of a sound */
export interface JetLagSound {
    /** Play the sound */
    play(): void;
    /** Stop playing the sound */
    stop(): void;
}

/** JetLagText describes some text to render */
export interface JetLagText {
    /**
     * Set the coordinates of the text
     * 
     * @param x The x coordinate for the text
     * @param y The y coordinate for the text
     */
    setPosition(x: number, y: number): void;

    /** Get the X coordinate for the text */
    getXPosition(): number;

    /** Get the Y coordinate for the text */
    getYPosition(): number;

    /** Get the width and height of the text */
    getBounds(): XY;

    /** Provide a string to display */
    setText(text: string): void;

    /** Get the part of the text that gets used by the renderer */
    getRenderObject(): any;
}

/** JetLagSprite is an abstract renderable context */
export interface JetLagSprite {
    /** Report the image name that is being shown */
    getImgName(): string;

    /** Set the X/Y coordinates of the sprite */
    setPosition(x: number, y: number): void;

    /** Report the X coordinate of the sprite */
    getXPosition(): number;

    /** Report the Y coordinate of the sprite */
    getYPosition(): number;

    /** Report the width of the sprite */
    getWidth(): number;

    /** Set the width of the sprite */
    setWidth(w: number): void;

    /** Report the height of the sprite */
    getHeight(): number;

    /** Set the height of the sprite */
    setHeight(h: number): void;

    /** Set the rotation of the sprite */
    setRotation(r: number): void;

    /** Set the position of a sprite relative to some anchor point (ax,ay) */
    setAnchoredPosition(ax: number, ay: number, x: number, y: number): void;

    /** Get the part of the sprite that is used by the renderer */
    getRenderObject(): any;

    /** Get the debug context for the sprite, for when we draw debug outlines */
    getDebugShape(): any;
}

/** 
 * JetLagDebugSprite is a renderable context that can draw a shape outline and
 * also a radial line
 */
export interface JetLagDebugSprite {
    /** Return the shape outline */
    getShape(): any;
    /** Return the line */
    getLine(): any;
}

/**
 * Renderable encapsulates anything that can be drawn on the screen.  In JetLag,
 * there are three ways that we might draw to the screen:
 * - Actor: has a physics body; uses that body to determine an image's x/y/theta
 * - Text: no physics body; must have an x/y/theta on its own
 * - Picture: no physics body; must have an x/y/theta on its own
 */
export interface Renderable {
    /**
     * Render something to the screen.  If the object needs to be updated before
     * rendering, do it here, too.  If the object should be culled (not rendered
     * because it isn't in view), that should be decided here too.
     */
    render(renderer: JetLagRenderer, camera: Camera, elapsedMillis: number): void;
}